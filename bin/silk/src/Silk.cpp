// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_EReg
#include <EReg.h>
#endif
#ifndef INCLUDED_Silk
#include <Silk.h>
#endif
#ifndef INCLUDED_Sys
#include <Sys.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_f3435c7f37db15cb_4_main,"Silk","main",0xf1f87692,"Silk.main","Silk.hx",4,0xed122129)

void Silk_obj::__construct() { }

Dynamic Silk_obj::__CreateEmpty() { return new Silk_obj; }

void *Silk_obj::_hx_vtable = 0;

Dynamic Silk_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Silk_obj > _hx_result = new Silk_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Silk_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x0b7fb6d9;
}

void Silk_obj::main(){
            	HX_GC_STACKFRAME(&_hx_pos_f3435c7f37db15cb_4_main)
HXLINE(   5)		::Array< ::String > arguments = ::Sys_obj::args();
HXLINE(   6)		bool _hx_tmp;
HXDLIN(   6)		if ((arguments->length != 0)) {
HXLINE(   6)			_hx_tmp = (arguments->__get(0) == HX_("help",c1,32,0b,45));
            		}
            		else {
HXLINE(   6)			_hx_tmp = true;
            		}
HXDLIN(   6)		if (_hx_tmp) {
HXLINE(   7)			::Sys_obj::println(HX_("Welcome to silk, a thin little wrapper around haxelib that gives some convienence with alternate names. \r\nUsage: silk [command] [options]\r\n  Basic\r\n    install or i                   : install a given library, or all libraries from a hxml file\r\n    update                         : update a single library (if given) or all installed libraries\r\n    remove                         : remove a given library/version\r\n    list                           : list all installed libraries\r\n    set                            : set the current version for a library\r\n  Information\r\n    search                         : list libraries matching a word\r\n    info or about                  : list information on a given library\r\n    user                           : list information on a given user\r\n    config                         : print the repository path\r\n    path                           : give paths to libraries' sources and necessary build definitions\r\n    libpath                        : returns the root path of a library\r\n    version                        : print the currently used haxelib version\r\n    help                           : display this list of options\r\n  Development\r\n    submit                         : submit or update a library package\r\n    register                       : register a new user\r\n    dev                            : set the development directory for a given library\r\n    git                            : use Git repository as library\r\n    hg                             : use Mercurial (hg) repository as library\r\n  Miscellaneous\r\n    setup                          : set the haxelib repository path\r\n    newrepo                        : create a new local repository\r\n    deleterepo                     : delete the local repository\r\n    convertxml                     : convert haxelib.xml file to haxelib.json\r\n    run                            : run the specified library with parameters\r\n    proxy                          : setup the Http proxy\r\n  Available switches\r\n    --flat                         : do not use --recursive cloning for git\r\n    --always or -y                 : answer all questions with yes\r\n    --debug                        : run in debug mode, imply not --quiet\r\n    --quiet                        : print less messages, imply not --debug\r\n    --system                       : run bundled haxelib version instead of latest update\r\n    --skip-dependencies or --no-dep: do not install dependencies\r\n    --never or -n                  : answer all questions with no\r\n    --global or -g                 : force global repo if a local one exists",42,f6,fe,b7));
            		}
            		else {
HXLINE(  47)			{
HXLINE(  47)				int _g = 0;
HXDLIN(  47)				int _g1 = arguments->length;
HXDLIN(  47)				while((_g < _g1)){
HXLINE(  47)					_g = (_g + 1);
HXDLIN(  47)					int i = (_g - 1);
HXLINE(  49)					 ::EReg gitRegex =  ::EReg_obj::__alloc( HX_CTX ,HX_("(.+)@([a-zA-Z0-9-._~:/?#\\[\\]@!$&'\\(\\)*+,;%=]+)",5c,57,c7,2e),HX_("",00,00,00,00));
HXLINE(  50)					 ::EReg versionRegex =  ::EReg_obj::__alloc( HX_CTX ,HX_("(.+)@((?:[0-9]+)\\.(?:[0-9]+)\\.(?:[0-9]+)(?:-(?:[0-9A-Za-z-]+(?:\\.[0-9A-Za-z-]+)*))?(?:\\+[0-9A-Za-z-]+)?)",e8,c4,82,11),HX_("",00,00,00,00));
HXLINE(  51)					 ::EReg githubRegex =  ::EReg_obj::__alloc( HX_CTX ,HX_("(.+)@(?:github:)?([a-z0-9\\-]+/[a-z0-9\\-]+)(?:#([a-z0-9]+))?",46,a0,e6,63),HX_("",00,00,00,00));
HXLINE(  52)					{
HXLINE(  52)						::String _g1 = arguments->__get(i);
HXDLIN(  52)						::String _hx_switch_0 = _g1;
            						if (  (_hx_switch_0==HX_("--no-dep",e3,d7,ea,5f)) ){
HXLINE(  58)							arguments[i] = HX_("--skip-dependencies",57,f6,ad,69);
HXDLIN(  58)							goto _hx_goto_1;
            						}
            						if (  (_hx_switch_0==HX_("-g",9a,27,00,00)) ){
HXLINE(  64)							arguments[i] = HX_("--global",c3,20,d6,04);
HXDLIN(  64)							goto _hx_goto_1;
            						}
            						if (  (_hx_switch_0==HX_("-n",a1,27,00,00)) ){
HXLINE(  56)							arguments[i] = HX_("--never",2c,5b,85,e6);
HXDLIN(  56)							goto _hx_goto_1;
            						}
            						if (  (_hx_switch_0==HX_("-y",ac,27,00,00)) ){
HXLINE(  54)							arguments[i] = HX_("--always",2f,fe,fa,a3);
HXDLIN(  54)							goto _hx_goto_1;
            						}
            						if (  (_hx_switch_0==HX_("about",4d,ce,f9,1a)) ){
HXLINE(  62)							arguments[i] = HX_("info",6e,38,bb,45);
HXDLIN(  62)							goto _hx_goto_1;
            						}
            						if (  (_hx_switch_0==HX_("add",21,f2,49,00)) ||  (_hx_switch_0==HX_("i",69,00,00,00)) ){
HXLINE(  60)							arguments[i] = HX_("install",1b,d5,9a,8d);
HXDLIN(  60)							goto _hx_goto_1;
            						}
            						if (  (_hx_switch_0==HX_("up",5b,66,00,00)) ){
HXLINE(  66)							arguments[i] = HX_("upgrade",9c,b4,31,63);
HXDLIN(  66)							goto _hx_goto_1;
            						}
            						/* default */{
HXLINE(  68)							::String versioning = _g1;
HXLINE(  52)							if (versionRegex->match(arguments->__get(i))) {
HXLINE(  69)								arguments[0] = HX_("install",1b,d5,9a,8d);
HXLINE(  70)								arguments[i] = versionRegex->matched(2);
HXLINE(  71)								arguments->insert(i,versionRegex->matched(1));
            							}
            							else {
HXLINE(  52)								if (githubRegex->match(arguments->__get(i))) {
HXLINE(  73)									arguments[0] = HX_("git",12,84,4e,00);
HXLINE(  74)									::String aUrl = HX_("https://github.com/",ca,bc,55,3f);
HXLINE(  75)									aUrl = (aUrl + githubRegex->matched(2));
HXLINE(  76)									if (::hx::IsNotNull( githubRegex->matched(3) )) {
HXLINE(  77)										aUrl = (aUrl + (HX_("/tree/",82,8e,e8,e0) + githubRegex->matched(3)));
            									}
HXLINE(  79)									arguments[i] = aUrl;
HXLINE(  80)									arguments->insert(i,githubRegex->matched(1));
            								}
            								else {
HXLINE(  81)									::String gitVersion = _g1;
HXDLIN(  81)									bool _hx_tmp;
HXDLIN(  81)									if (gitRegex->match(arguments->__get(i))) {
HXLINE(  81)										_hx_tmp = (arguments->__get(0) == HX_("install",1b,d5,9a,8d));
            									}
            									else {
HXLINE(  81)										_hx_tmp = false;
            									}
HXDLIN(  81)									if (_hx_tmp) {
HXLINE(  83)										arguments[0] = HX_("git",12,84,4e,00);
HXLINE(  84)										arguments[i] = gitRegex->matched(2);
HXLINE(  85)										arguments->insert(i,gitRegex->matched(1));
            									}
            								}
            							}
            						}
            						_hx_goto_1:;
            					}
            				}
            			}
HXLINE(  88)			::Sys_obj::exit(::Sys_obj::command(HX_("haxelib",df,b6,80,08),arguments));
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Silk_obj,main,(void))


Silk_obj::Silk_obj()
{
}

bool Silk_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"main") ) { outValue = main_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Silk_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Silk_obj_sStaticStorageInfo = 0;
#endif

::hx::Class Silk_obj::__mClass;

static ::String Silk_obj_sStaticFields[] = {
	HX_("main",39,38,56,48),
	::String(null())
};

void Silk_obj::__register()
{
	Silk_obj _hx_dummy;
	Silk_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("Silk",b5,c0,2c,37);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Silk_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Silk_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Silk_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Silk_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Silk_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

